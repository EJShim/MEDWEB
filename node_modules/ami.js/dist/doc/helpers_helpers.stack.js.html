<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: helpers/helpers.stack.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: helpers/helpers.stack.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*** Imports ***/
import HelpersBorder      from '../../src/helpers/helpers.border';
import HelpersBoundingBox from '../../src/helpers/helpers.boundingbox';
import HelpersSlice       from '../../src/helpers/helpers.slice';

/**
 * Helper to easily display and interact with a stack.&lt;br>
 *&lt;br>
 * Defaults:&lt;br>
 *   - orientation: 0 (acquisition direction)&lt;br>
 *   - index: middle slice in acquisition direction&lt;br>
 *&lt;br>
 * Features:&lt;br>
 *   - slice from the stack (in any direction)&lt;br>
 *   - slice border&lt;br>
 *   - stack bounding box&lt;br>
 *&lt;br>
 * Live demo at: {@link http://jsfiddle.net/gh/get/library/pure/fnndsc/ami/tree/master/lessons/01#run|Lesson 01}
 *
 * @example
 * let stack = new VJS.Models.Stack();
 * ... // prepare the stack
 * 
 * let stackHelper = new VJS.Helpers.Stack(stack);
 * stackHelper.bbox.color = 0xF9F9F9;
 * stackHelper.border.color = 0xF9F9F9;
 *
 * let scene = new THREE.Scene();
 * scene.add(stackHelper);
 *
 * @extends THREE.Object3D
 *
 * @see module:helpers/border
 * @see module:helpers/boundingbox
 * @see module:helpers/slice
 *
 * @module helpers/stack
 */
export default class HelpersStack extends THREE.Object3D{
  constructor(stack){
    //
    super();

    this._stack = stack;
    this._bBox = null;
    this._slice = null;
    this._border = null;
    this._dummy = null;

    this._orientation = 0;
    this._index = 0;

    this._uniforms = null;
    this._autoWindowLevel = false;
    this._outOfBounds = false;

    // this._arrow = {
    //   visible: true,
    //   color: 0xFFF336,
    //   length: 20,
    //   material: null,
    //   geometry: null,
    //   mesh: null
    // };
    this._create();
  }

  //
  // PUBLIC METHODS
  //

  //
  // SETTERS/GETTERS
  //

  /**
   * Get stack.
   *
   * @type {ModelsStack}
   */
  get stack(){
    return this._stack;
  }

  /**
   * Get bounding box helper.
   *
   * @type {HelpersBoundingBox}
   */
  get bbox(){
    return this._bBox;
  }

  /**
   * Get slice helper.
   *
   * @type {HelpersSlice}
   */
  get slice(){
    return this._slice;
  }

  /**
   * Get border helper.
   *
   * @type {HelpersSlice}
   */
  get border(){
    return this._border;
  }

  /**
   * Set/get current slice index.&lt;br>
   * Sets outOfBounds flag to know if target index is in/out stack bounding box.&lt;br>
   * &lt;br>
   * Internally updates the sliceHelper index and position. Also updates the
   * borderHelper with the updated sliceHelper.
   *
   * @type {number}
   */
  get index(){
    return this._index;
  }

  set index(index){

    this._index = index;

    // update the slice
    this._slice.index = index;
    let halfDimensions = this._stack.halfDimensionsIJK;
    this._slice.planePosition = this._prepareSlicePosition(halfDimensions, this._index);

    // also update the border
    this._border.helpersSlice = this._slice;

    // update ourOfBounds flag
    this._isIndexOutOfBounds();
  }

  /**
   * Set/get current slice orientation.&lt;br>
   * Values: &lt;br>
   *   - 0: acquisition direction (slice normal is z_cosine)&lt;br>
   *   - 1: next direction (slice normal is x_cosine)&lt;br>
   *   - 2: next direction (slice normal is y_cosine)&lt;br>
   *   - n: set orientation to 0&lt;br>
   * &lt;br>
   * Internally updates the sliceHelper direction. Also updates the
   * borderHelper with the updated sliceHelper.
   *
   * @type {number}
   */
  set orientation(orientation){
    this._orientation = orientation;
    this._slice.planeDirection = this._prepareDirection(this._orientation);

    // also update the border
    this._border.helpersSlice = this._slice;
  }

  get orientation(){
    return this._orientation;
  }

  /**
   * Set/get the outOfBound flag.
   *
   * @type {boolean}
   */
  set outOfBounds(outOfBounds){
    this._outOfBounds = outOfBounds;
  }

  get outOfBounds(){
    return this._outOfBounds;
  }

  //
  // PRIVATE METHODS
  //

  /**
   * Initial setup, including stack prepare, bbox prepare, slice prepare and
   * border prepare.
   *
   * @private
   */
  _create(){
    if (this._stack) {

      // prepare sthe stack internals
      this._prepareStack();

      // prepare visual objects
      this._prepareBBox();
      this._prepareSlice();
      this._prepareBorder();
      // todo: Arrow

    } else {
      window.console.log('no stack to be prepared...');
    }
  }

  /**
   * Given orientation, check if index is in/out of bounds.
   *
   * @private
   */
  _isIndexOutOfBounds(){

    let dimensionsIJK = this._stack.dimensionsIJK;
    let dimensions = 0;
    switch(this._orientation){
      case 0:
        dimensions = dimensionsIJK.z;
        break;
      case 1:
        dimensions = dimensionsIJK.x;
        break;
      case 2:
        dimensions = dimensionsIJK.y;
        break;
      default:
        // do nothing!
        break;
    }

    if(this._index >= dimensions || this._index &lt; 0){
      this._outOfBounds = true;
    }
    else{
      this._outOfBounds = false;
    }
  }

  /**
   * Prepare a stack for visualization. (image to world transform, frames order,
   * pack data into 8 bits textures, etc.)
   *
   * @private
   */
  _prepareStack(){
    // make sure there is something, if not throw an error
    // compute image to workd transform, order frames, etc.
    if(!this._stack.prepared){
      this._stack.prepare();
    }
    
    // pack data into 8 bits rgba texture for the shader
    // this one can be slow...
    if(!this._stack.packed){
      this._stack.pack();
    }
  }

  /**
   * Setup bounding box helper given prepared stack and add bounding box helper
   * to stack helper.
   *
   * @private
   */
  _prepareBBox(){
    this._bBox = new HelpersBoundingBox(this._stack);
    this.add(this._bBox);
  }

  /**
   * Setup border helper given slice helper and add border helper
   * to stack helper.
   *
   * @private
   */
  _prepareBorder(){
    this._border = new HelpersBorder(this._slice);
    this.add(this._border);
  }

  /**
   * Setup slice helper given prepared stack helper and add slice helper
   * to stack helper.
   *
   * @private
   */
  _prepareSlice(){
    let halfDimensionsIJK = this._stack.halfDimensionsIJK;
    // compute initial index given orientation
    this._index = this._prepareSliceIndex(halfDimensionsIJK);
    // compute initial position given orientation and index
    let position = this._prepareSlicePosition(halfDimensionsIJK, this._index);
    // compute initial direction orientation
    let direction = this._prepareDirection(this._orientation);

    this._slice = new HelpersSlice(this._stack, this._index, position, direction);
    this.add(this._slice);
  }

  /**
   * Compute slice index depending on orientation.
   *
   * @param {THREE.Vector3} indices - Indices in each direction.
   *
   * @returns {number} Slice index according to current orientation.
   *
   * @private
   */
  _prepareSliceIndex(indices){
    let index = 0;
    switch(this._orientation){
      case 0:
        index = Math.floor(indices.z);
        break;
      case 1:
        index = Math.floor(indices.x);
        break;
      case 2:
        index = Math.floor(indices.y);
        break;
      default:
        // do nothing!
        break;
    }
    return index;
  }

  /**
   * Compute slice position depending on orientation.
   * Sets index in proper location of reference position.
   *
   * @param {THREE.Vector3} rPosition - Reference position.
   * @param {number} index - Current index.
   *
   * @returns {number} Slice index according to current orientation.
   *
   * @private
   */
  _prepareSlicePosition(rPosition, index){
    let position = new THREE.Vector3(0, 0, 0);
    switch(this._orientation){
      case 0:
        position = new THREE.Vector3(
          Math.floor(rPosition.x),
          Math.floor(rPosition.y),
          index);
        break;
      case 1:
        position = new THREE.Vector3(
          index,
          Math.floor(rPosition.y),
          Math.floor(rPosition.z));
        break;
      case 2:
        position = new THREE.Vector3(
          Math.floor(rPosition.x),
          index,
          Math.floor(rPosition.z));
        break;
      default:
        // do nothing!
        break;
    }
    return position;
  }

  /**
   * Compute slice direction depending on orientation.
   *
   * @param {number} orientation - Slice orientation.
   *
   * @returns {THREE.Vector3} Slice direction
   *
   * @private
   */
  _prepareDirection(orientation){
    let direction = new THREE.Vector3(0, 0, 1);
    switch(orientation){
      case 0:
        direction = new THREE.Vector3(0, 0, 1);
        break;
      case 1:
        direction = new THREE.Vector3(1, 0, 0);
        break;
      case 2:
        direction = new THREE.Vector3(0, 1, 0);
        break;
      default:
        // do nothing!
        break;
    }

    return direction;
  }

}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a></li><li><a href="module-core_validators.html">core/validators</a></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_material_mixin.html">helpers/material/mixin</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_voxel.html">helpers/voxel</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a></li><li><a href="module-models_frame.html">models/frame</a></li><li><a href="module-models_series.html">models/series</a></li><li><a href="module-models_stack.html">models/stack</a></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a></li><li><a href="module-widgets_squareProbe.html">widgets/squareProbe</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Wed Nov 16 2016 09:44:56 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
