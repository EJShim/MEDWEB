<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>helpers/helpers.slice.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li></ul><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a><ul class='methods'><li data-type='method'><a href="module-cameras_orthographic.html#center">center</a></li><li data-type='method'><a href="module-cameras_orthographic.html#init">init</a></li><li data-type='method'><a href="module-cameras_orthographic.html#invertColumns">invertColumns</a></li><li data-type='method'><a href="module-cameras_orthographic.html#invertRows">invertRows</a></li><li data-type='method'><a href="module-cameras_orthographic.html#rotate">rotate</a></li></ul></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a><ul class='methods'><li data-type='method'><a href="module-core_intersections.html#.aabbPlane">aabbPlane</a></li></ul></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a><ul class='methods'><li data-type='method'><a href="module-core_utils.html#.bbox">bbox</a></li></ul></li><li><a href="module-core_validators.html">core/validators</a><ul class='methods'><li data-type='method'><a href="module-core_validators.html#.box">box</a></li><li data-type='method'><a href="module-core_validators.html#.matrix4">matrix4</a></li><li data-type='method'><a href="module-core_validators.html#.ray">ray</a></li><li data-type='method'><a href="module-core_validators.html#.vector3">vector3</a></li></ul></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a><ul class='methods'><li data-type='method'><a href="module-geometries_slice.html#.centerOfMass">centerOfMass</a></li><li data-type='method'><a href="module-geometries_slice.html#.orderIntersections">orderIntersections</a></li></ul></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a><ul class='methods'><li data-type='method'><a href="module-helpers_stack.html#_create">_create</a></li><li data-type='method'><a href="module-helpers_stack.html#_isIndexOutOfBounds">_isIndexOutOfBounds</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareBBox">_prepareBBox</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareBorder">_prepareBorder</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareDirection">_prepareDirection</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSlice">_prepareSlice</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSliceIndex">_prepareSliceIndex</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSlicePosition">_prepareSlicePosition</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareStack">_prepareStack</a></li></ul></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_voxel.html">helpers/voxel</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a><ul class='methods'><li data-type='method'><a href="module-loaders_base.html#free">free</a></li></ul></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a><ul class='methods'><li data-type='method'><a href="module-models_base.html#_validateModelArray">_validateModelArray</a></li><li data-type='method'><a href="module-models_base.html#merge">merge</a></li><li data-type='method'><a href="module-models_base.html#mergeModels">mergeModels</a></li><li data-type='method'><a href="module-models_base.html#validate">validate</a></li></ul></li><li><a href="module-models_frame.html">models/frame</a><ul class='methods'><li data-type='method'><a href="module-models_frame.html#_compareArrays">_compareArrays</a></li><li data-type='method'><a href="module-models_frame.html#cosines">cosines</a></li><li data-type='method'><a href="module-models_frame.html#merge">merge</a></li></ul></li><li><a href="module-models_series.html">models/series</a><ul class='methods'><li data-type='method'><a href="module-models_series.html#merge">merge</a></li><li data-type='method'><a href="module-models_series.html#mergeSeries">mergeSeries</a></li><li data-type='method'><a href="module-models_series.html#validate">validate</a></li></ul></li><li><a href="module-models_stack.html">models/stack</a><ul class='methods'><li data-type='method'><a href="module-models_stack.html#prepare">prepare</a></li></ul></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a><ul class='methods'><li data-type='method'><a href="module-parsers_dicom.html#_swapFrame">_swapFrame</a></li></ul></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-shaders_layer.html">shaders/layer</a></li><li><a href="module-shaders_raycasting.html">shaders/raycasting</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a><ul class='methods'><li data-type='method'><a href="module-widgets_handle.html#onMove">onMove</a></li></ul></li><li><a href="module-widgets_squareProbe.html">widgets/squareProbe</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">helpers/helpers.slice.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import GeometriesSlice from '../../src/geometries/geometries.slice';
import ShadersData     from '../../src/shaders/shaders.data';

let glslify =  require('glslify');

/**
 * @module helpers/slice
 */

export default class HelpersSlice extends THREE.Object3D{
  constructor(stack,
              index = 0,
              position = new THREE.Vector3(0, 0, 0),
              direction = new THREE.Vector3(0, 0, 1),
              aabbSpace = 'IJK') {
    //
    super();

    // private vars
    this._stack = stack;

    // image settings
    // index only used to grab window/level and intercept/slope
    this._invert = this._stack.invert;

    this._lut = 'none';
    this._lutTexture = null;
    // if auto === true, get from index
    // else from stack which holds the default values
    this._intensityAuto = true;
    this._interpolation = 1; // default to trilinear interpolation
    // starts at 0
    this._index = index;
    this._windowWidth = null;
    this._windowCenter = null;
    this._rescaleSlope = null;
    this._rescaleIntercept = null;

    // Object3D settings
    // shape
    this._planePosition = position;
    this._planeDirection = direction;
    // change aaBBSpace changes the box dimensions
    // also changes the transform
    // there is also a switch to move back mesh to LPS space automatically
    this._aaBBspace = aabbSpace; // or LPS -> different transforms, esp for the geometry/mesh
    this._material = null;
    this._uniforms = ShadersData.uniforms();
    this._geometry = null;
    this._mesh = null;
    this._visible = true;

    // update dimensions, center, etc.
    // depending on aaBBSpace
    this._init();

    // update object
    this._create();
  }

  // getters/setters

  get stack() {
    return this._stack;
  }

  set stack(stack) {
    this._stack = stack;
  }

  get windowWidth() {
    return this._windowWidth;
  }

  set windowWidth(windowWidth) {
    this._windowWidth = windowWidth;
    this.updateIntensitySettingsUniforms();
  }

  get windowCenter() {
    return this._windowCenter;
  }

  set windowCenter(windowCenter) {
    this._windowCenter = windowCenter;
    this.updateIntensitySettingsUniforms();
  }

  get rescaleSlope() {
    return this._rescaleSlope;
  }

  set rescaleSlope(rescaleSlope) {
    this._rescaleSlope = rescaleSlope;
    this.updateIntensitySettingsUniforms();
  }

  get rescaleIntercept() {
    return this._rescaleIntercept;
  }

  set rescaleIntercept(rescaleIntercept) {
    this._rescaleIntercept = rescaleIntercept;
    this.updateIntensitySettingsUniforms();
  }

  get invert() {
    return this._invert;
  }

  set invert(invert) {
    this._invert = invert;
    this.updateIntensitySettingsUniforms();
  }

  get lut() {
    return this._lut;
  }

  set lut(lut) {
    this._lut = lut;
  }

  get lutTexture() {
    return this._lutTexture;
  }

  set lutTexture(lutTexture) {
    this._lutTexture = lutTexture;
    this.updateIntensitySettingsUniforms();
  }

  get intensityAuto() {
    return this._intensityAuto;
  }

  set intensityAuto(intensityAuto) {
    this._intensityAuto = intensityAuto;
    this.updateIntensitySettings();
    this.updateIntensitySettingsUniforms();
  }

  get interpolation() {
    return this._interpolation;
  }

  set interpolation(interpolation) {
    this._interpolation = interpolation;
    this.updateIntensitySettingsUniforms();
  }

  get index() {
    return this._index;
  }

  set index(index) {
    this._index = index;
    this._update();
  }

  set planePosition(position) {
    this._planePosition = position;
    this._update();
  }

  get planePosition() {
    return this._planePosition;
  }

  set planeDirection(direction) {
    this._planeDirection = direction;
    this._update();
  }

  get planeDirection() {
    return this._planeDirection;
  }

  set halfDimensions(halfDimensions) {
    this._halfDimensions = halfDimensions;
  }

  get halfDimensions() {
    return this._halfDimensions;
  }

  set center(center) {
    this._center = center;
  }

  get center() {
    return this._center;
  }

  set aabbSpace(aabbSpace) {
    this._aaBBspace = aabbSpace;
    this._init();
  }

  get aabbSpace() {
    return this._aaBBspace;
  }

  set mesh(mesh) {
    this._mesh = mesh;
  }

  get mesh() {
    return this._mesh;
  }

  set geometry(geometry) {
    this._geometry = geometry;
  }

  get geometry() {
    return this._geometry;
  }

  _init() {
    if (!this._stack || !this._stack._prepared || !this._stack._packed) {
      return;
    }

    if (this._aaBBspace === 'IJK') {
      this._halfDimensions = this._stack.halfDimensionsIJK;
      this._center = new THREE.Vector3(
        this._stack.halfDimensionsIJK.x - 0.5,
        this._stack.halfDimensionsIJK.y - 0.5,
        this._stack.halfDimensionsIJK.z - 0.5);
      this._toAABB = new THREE.Matrix4();
    } else {
      // LPS
      let aaBBox  = this._stack.AABBox();
      this._halfDimensions = aaBBox.clone().multiplyScalar(0.5);
      this._center = this._stack.centerAABBox();
      this._toAABB = this._stack.lps2AABB;
    }
  }

  // private methods
  _create() {

    if (!this._stack || !this._stack.prepared || !this._stack.packed) {
      return;
    }

    // Convenience vars
    try {
      this._geometry = new GeometriesSlice(
        this._halfDimensions,
        this._center,
        this._planePosition,
        this._planeDirection,
        this._toAABB);
    }
    catch (e) {
      window.console.log(e);
      window.console.log('invalid slice geometry - exiting...');
      return;
    }

    if (!this._geometry.vertices) {
      return;
    }

    if (!this._material) {
      //
      this._uniforms.uTextureSize.value = this._stack.textureSize;
      this._uniforms.uDataDimensions.value =
        [this._stack.dimensionsIJK.x,
         this._stack.dimensionsIJK.y,
         this._stack.dimensionsIJK.z];
      this._uniforms.uWorldToData.value = this._stack.lps2IJK;
      this._uniforms.uNumberOfChannels.value = this._stack.numberOfChannels;
      this._uniforms.uPixelType.value = this._stack.pixelType;
      this._uniforms.uBitsAllocated.value = this._stack.bitsAllocated;
      this._uniforms.uPackedPerPixel.value = this._stack.packedPerPixel;

      // compute texture if material exist
      let textures = [];
      // replace 7 by a letiable!!!!
      for (let m = 0; m &lt; this._stack.rawData.length; m++) {
        let tex = new THREE.DataTexture(
          this._stack.rawData[m],
          this._stack.textureSize, this._stack.textureSize,
          this._stack.textureType, THREE.UnsignedByteType,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
          THREE.NearestFilter, THREE.NearestFilter);
        tex.needsUpdate = true;
        tex.flipY = true;
        textures.push(tex);
      }

      this._uniforms.uTextureContainer.value = textures;

      this._material = new THREE.ShaderMaterial({
        'side': THREE.DoubleSide,
        'uniforms': this._uniforms,
        'vertexShader': glslify('../shaders/shaders.data.vert'),
        'fragmentShader': glslify('../shaders/shaders.data.frag')
      });
    }

    // update intensity related stuff
    this.updateIntensitySettings();
    this.updateIntensitySettingsUniforms();

    // create the mesh!
    this._mesh = new THREE.Mesh(this._geometry, this._material);
    if (this._aaBBspace === 'IJK') {
      this._mesh.applyMatrix(this._stack.ijk2LPS);
    }

    this._mesh.visible = this._visible;

    // and add it!
    this.add(this._mesh);
  }

  updateIntensitySettings() {
    // if auto, get from frame index
    if (this._intensityAuto) {
      this.updateIntensitySetting('windowCenter');
      this.updateIntensitySetting('windowWidth');
      this.updateIntensitySetting('rescaleSlope');
      this.updateIntensitySetting('rescaleIntercept');
    } else {
      if (this._windowCenter === null) {
        this._windowCenter = this._stack.windowCenter;
      }

      if (this.__windowWidth === null) {
        this._windowWidth = this._stack.windowWidth;
      }

      if (this._rescaleSlope === null) {
        this._rescaleSlope = this._stack.rescaleSlope;
      }

      if (this._rescaleIntercept === null) {
        this._rescaleIntercept = this._stack.rescaleIntercept;
      }
    }

  }

  updateIntensitySettingsUniforms() {
    // set slice window center and width
    this._uniforms.uRescaleSlopeIntercept.value = [this._rescaleSlope, this._rescaleIntercept];
    this._uniforms.uWindowCenterWidth.value = [this._windowCenter, this._windowWidth];

    // invert
    this._uniforms.uInvert.value = this._invert === true ? 1 : 0;

    // interpolation
    this._uniforms.uInterpolation.value = this._interpolation;

    // lut
    if (this._lut === 'none') {
      this._uniforms.uLut.value = 0;
    } else {
      this._uniforms.uLut.value = 1;
      this._uniforms.uTextureLUT.value = this._lutTexture;
    }
  }

  updateIntensitySetting(setting) {
    if (this._stack.frame[this._index] &amp;&amp;
        this._stack.frame[this._index][setting]) {
      this['_' + setting] = this._stack.frame[this._index][setting];
    } else {
      this['_' + setting] = this._stack[setting];
    }
  }

  _update() {
    // update slice
    if (this._mesh) {
      this.remove(this._mesh);
      this._mesh.geometry.dispose();
      this._mesh.geometry = null;
      // we do not want to dispose the texture!
      // this._mesh.material.dispose();
      // this._mesh.material = null;
      this._mesh = null;
    }

    this._create();
  }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Thu Sep 29 2016 15:06:14 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
