<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>cameras/cameras.orthographic.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li></ul><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a><ul class='methods'><li data-type='method'><a href="module-cameras_orthographic.html#center">center</a></li><li data-type='method'><a href="module-cameras_orthographic.html#init">init</a></li><li data-type='method'><a href="module-cameras_orthographic.html#invertColumns">invertColumns</a></li><li data-type='method'><a href="module-cameras_orthographic.html#invertRows">invertRows</a></li><li data-type='method'><a href="module-cameras_orthographic.html#rotate">rotate</a></li></ul></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a><ul class='methods'><li data-type='method'><a href="module-core_intersections.html#.aabbPlane">aabbPlane</a></li></ul></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a><ul class='methods'><li data-type='method'><a href="module-core_utils.html#.bbox">bbox</a></li></ul></li><li><a href="module-core_validators.html">core/validators</a><ul class='methods'><li data-type='method'><a href="module-core_validators.html#.box">box</a></li><li data-type='method'><a href="module-core_validators.html#.matrix4">matrix4</a></li><li data-type='method'><a href="module-core_validators.html#.ray">ray</a></li><li data-type='method'><a href="module-core_validators.html#.vector3">vector3</a></li></ul></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a><ul class='methods'><li data-type='method'><a href="module-geometries_slice.html#.centerOfMass">centerOfMass</a></li><li data-type='method'><a href="module-geometries_slice.html#.orderIntersections">orderIntersections</a></li></ul></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a><ul class='methods'><li data-type='method'><a href="module-helpers_stack.html#_create">_create</a></li><li data-type='method'><a href="module-helpers_stack.html#_isIndexOutOfBounds">_isIndexOutOfBounds</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareBBox">_prepareBBox</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareBorder">_prepareBorder</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareDirection">_prepareDirection</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSlice">_prepareSlice</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSliceIndex">_prepareSliceIndex</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSlicePosition">_prepareSlicePosition</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareStack">_prepareStack</a></li></ul></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_voxel.html">helpers/voxel</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a><ul class='methods'><li data-type='method'><a href="module-loaders_base.html#free">free</a></li></ul></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a><ul class='methods'><li data-type='method'><a href="module-models_base.html#_validateModelArray">_validateModelArray</a></li><li data-type='method'><a href="module-models_base.html#merge">merge</a></li><li data-type='method'><a href="module-models_base.html#mergeModels">mergeModels</a></li><li data-type='method'><a href="module-models_base.html#validate">validate</a></li></ul></li><li><a href="module-models_frame.html">models/frame</a><ul class='methods'><li data-type='method'><a href="module-models_frame.html#_compareArrays">_compareArrays</a></li><li data-type='method'><a href="module-models_frame.html#cosines">cosines</a></li><li data-type='method'><a href="module-models_frame.html#merge">merge</a></li></ul></li><li><a href="module-models_series.html">models/series</a><ul class='methods'><li data-type='method'><a href="module-models_series.html#merge">merge</a></li><li data-type='method'><a href="module-models_series.html#mergeSeries">mergeSeries</a></li><li data-type='method'><a href="module-models_series.html#validate">validate</a></li></ul></li><li><a href="module-models_stack.html">models/stack</a><ul class='methods'><li data-type='method'><a href="module-models_stack.html#prepare">prepare</a></li></ul></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a><ul class='methods'><li data-type='method'><a href="module-parsers_dicom.html#_swapFrame">_swapFrame</a></li></ul></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-shaders_layer.html">shaders/layer</a></li><li><a href="module-shaders_raycasting.html">shaders/raycasting</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a><ul class='methods'><li data-type='method'><a href="module-widgets_handle.html#onMove">onMove</a></li></ul></li><li><a href="module-widgets_squareProbe.html">widgets/squareProbe</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">cameras/cameras.orthographic.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Intersections from '../core/core.intersections';
import Validators    from '../core/core.validators';

/** 
 * Orthographic camera from THREE.JS with some extra convenience
 * functionalities.
 *
 * @example
 * //
 * //
 *
 * @module cameras/orthographic
 */
export default class CamerasOrthographic extends THREE.OrthographicCamera{
  constructor(left, right, top, bottom, near, far) {
    super(left, right, top, bottom, near, far);

    this._front = null;
    this._back = null;

    this._xCosine = null;
    this._yCosine = null;
    this._zCosine = null;

    this._controls = null;
    this._box = null;
    this._canvas = {
      width: null,
      height: null
    }

    this._fromFront = true;
    this._angle = 0;
  }

  /**
   * Initialize orthographic camera variables
   */
  init(xCosine, yCosine, zCosine, controls, box, canvas){
    //
    if(!(Validators.vector3(xCosine) &amp;&amp;
      Validators.vector3(yCosine) &amp;&amp;
      Validators.vector3(zCosine) &amp;&amp;
      Validators.box(box) &amp;&amp;
      controls)){
      window.console.log('Invalid input provided.');

      return false;
    }

    this._xCosine = xCosine;
    this._yCosine = yCosine;
    this._zCosine = zCosine;
    this._controls = controls;
    this._box = box;
    this._canvas = canvas;

    let ray = {
      position: this._box.center,
      direction: this._zCosine
    }

    let intersections = Intersections.rayBox(ray, this._box);
    this._front = intersections[0];
    this._back = intersections[1];

    // set default values
    this.up.set(this._yCosine.x, this._yCosine.y, this._yCosine.z);
    this._updateCanvas();
    this._updatePositionAndTarget(this._front, this._back);
    this._updateMatrices();
  }

  /**
   * Invert rows in the current slice.
   * Inverting rows in 2 steps:
   *   * Flip the "up" vector
   *   * Look at the slice from the other side 
   */
  invertRows() {
    // flip "up" vector
    // we flip up first because invertColumns update projectio matrices
    this.up.multiplyScalar(-1);
    // this._angle -= 180;

    // Rotate the up vector around the "zCosine"
    // let rotation = new THREE.Matrix4().makeRotationAxis(
    //   this._zCosine, 
    //   Math.PI);
    // this.up.applyMatrix4(rotation);

    // this._updateMatrices();

    
    this.invertColumns();
  }

  /**
   * Invert rows in the current slice.
   * Inverting rows in 1 step:
   *   * Look at the slice from the other side 
   */
  invertColumns( ) {

    this.center();
    // rotate 180 degrees around the up vector...
    let oppositePosition = this._oppositePosition(this.position);

    // update posistion and target
    // clone is needed because this.position is overwritten in method
    this._updatePositionAndTarget(oppositePosition, this.position.clone());
    this._updateMatrices();
    this._fromFront = !this._fromFront;

    let clockwise = 1;
    if( !this._fromFront ){

      clockwise = -1;
      
    }

    this._angle %= 360;
    this._angle = 360 - this._angle;

  }

  /**
   * Center slice in the camera FOV.
   * It also updates the controllers properly.
   * We can center a camera from the front or from the back.
   */
  center(){
    if (this._fromFront) {
      this._updatePositionAndTarget(this._front, this._back);
    } else {
      this._updatePositionAndTarget(this._back, this._front);
    }

    this._updateMatrices();
  }

  /**
   * Pi/2 rotation around the zCosine axis.
   * Clock-wise rotation from the user point of view.
   */
  rotate( angle=null ) {

    this.center();

    var computedAngle = 90;

    let clockwise = 1;
    if( !this._fromFront ){

      clockwise = -1;
      
    }

    if( angle === null ){

      computedAngle *= -clockwise;
      this._angle += 90;

    }
    else{
      
      computedAngle = 360 - clockwise * (angle - this._angle);
      this._angle = angle;

    }

    this._angle %= 360;

    // Rotate the up vector around the "zCosine"
    let rotation = new THREE.Matrix4().makeRotationAxis(
      this._zCosine, 
      computedAngle * Math.PI/180);
    this.up.applyMatrix4(rotation);

    this._updateMatrices();
  }

  // dimensions[0] // width
  // dimensions[1] // height
  // direction= 0 width, 1 height, 2 best
  // factor
  fitBox(direction = 0, factor=1.5) {
    //
    // if (!(dimensions &amp;&amp; dimensions.length >= 2)) {
    //   window.console.log('Invalid dimensions container.');
    //   window.console.log(dimensions);

    //   return false;
    // }

    //
    let zoom = 1;

    // update zoom
    switch (direction){
      case 0:
        zoom = factor * this._computeZoom(this._canvas.width, this._xCosine);
        break;
      case 1:
        zoom = factor * this._computeZoom(this._canvas.height, this._yCosine);
        break;
      case 2:
        zoom = factor * (Math.min(
          this._computeZoom(this._canvas.width, this._xCosine),
          this._computeZoom(this._canvas.height, this._yCosine)
        ));
        break;
      default:
        break;
    }

    if(!zoom){
      return false
    }

    this.zoom = zoom;

    this.center();
  }

  _updateCanvas(){
    var camFactor = 2;
    this.left = -this._canvas.width / camFactor;
    this.right = this._canvas.width / camFactor;
    this.top = this._canvas.height / camFactor;
    this.bottom = -this._canvas.height / camFactor;

    this._updateMatrices();
    this.controls.handleResize();
  }

  _oppositePosition(position){
    let oppositePosition = position.clone();
    // center world postion around box center
    oppositePosition.sub(this._box.center);
    // rotate
    let rotation = new THREE.Matrix4().makeRotationAxis(
      this.up, 
      Math.PI);

    oppositePosition.applyMatrix4(rotation);
    // translate back to world position
    oppositePosition.add(this._box.center);
    return oppositePosition;
  }

  _computeZoom(dimension, direction) {

    if(!(dimension &amp;&amp; dimension > 0)){
      window.console.log('Invalid dimension provided.');
      window.console.log(dimension);
      return false;
    }

    // ray
    let ray = {
      position: this._box.center.clone(),
      direction: direction
    };

    let intersections = Intersections.rayBox(ray, this._box);
    if (intersections.length &lt; 2) {
      window.console.log('Can not adjust the camera ( &lt; 2 intersections).');
      window.console.log(ray);
      window.console.log(this._box);
      return false;
    }

    return dimension / intersections[0].distanceTo(intersections[1]);
  }

  _updatePositionAndTarget(position, target){
      // position
      this.position.set(position.x, position.y, position.z);

      // targets
      this.lookAt(target.x, target.y, target.z);
      this._controls.target.set(target.x, target.y, target.z);
  }

  _updateMatrices() {
    this._controls.update();
    // THEN camera
    this.updateProjectionMatrix();
    this.updateMatrixWorld();
  }

  set xCosine(xCosine) {
    this._xCosine = xCosine;
  }

  get xCosine() {
    return this._xCosine;
  }

  set yCosine(yCosine) {
    this._yCosine = yCosine;
  }

  get yCosine() {
    return this._yCosine;
  }

  set zCosine(zCosine) {
    this._zCosine = zCosine;
  }

  get zCosine() {
    return this._zCosine;
  }

  set controls(controls) {
    this._controls = controls;
  }

  get controls() {
    return this._controls;
  }

  set box(box) {
    this._box = box;
  }

  get box() {
    return this._box;
  }

  set canvas(canvas){
    this._canvas = canvas;
    this._updateCanvas();
  }

  get canvas(){
    return this._canvas;
  }

  set angle(angle){
    this.rotate(angle);
  }

  get angle(){
    return this._angle;
  }

}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Thu Sep 29 2016 15:06:14 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
