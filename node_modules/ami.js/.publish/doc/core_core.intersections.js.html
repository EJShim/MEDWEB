<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/core.intersections.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports.html">exports</a></li></ul><h3>Modules</h3><ul><li><a href="module-cameras.html">cameras</a></li><li><a href="module-cameras_orthographic.html">cameras/orthographic</a><ul class='methods'><li data-type='method'><a href="module-cameras_orthographic.html#center">center</a></li><li data-type='method'><a href="module-cameras_orthographic.html#init">init</a></li><li data-type='method'><a href="module-cameras_orthographic.html#invertColumns">invertColumns</a></li><li data-type='method'><a href="module-cameras_orthographic.html#invertRows">invertRows</a></li><li data-type='method'><a href="module-cameras_orthographic.html#rotate">rotate</a></li></ul></li><li><a href="module-core.html">core</a></li><li><a href="module-core_intersections.html">core/intersections</a><ul class='methods'><li data-type='method'><a href="module-core_intersections.html#.aabbPlane">aabbPlane</a></li></ul></li><li><a href="module-core_pack.html">core/pack</a></li><li><a href="module-core_utils.html">core/utils</a><ul class='methods'><li data-type='method'><a href="module-core_utils.html#.bbox">bbox</a></li></ul></li><li><a href="module-core_validators.html">core/validators</a><ul class='methods'><li data-type='method'><a href="module-core_validators.html#.box">box</a></li><li data-type='method'><a href="module-core_validators.html#.matrix4">matrix4</a></li><li data-type='method'><a href="module-core_validators.html#.ray">ray</a></li><li data-type='method'><a href="module-core_validators.html#.vector3">vector3</a></li></ul></li><li><a href="module-geometries.html">geometries</a></li><li><a href="module-geometries_slice.html">geometries/slice</a><ul class='methods'><li data-type='method'><a href="module-geometries_slice.html#.centerOfMass">centerOfMass</a></li><li data-type='method'><a href="module-geometries_slice.html#.orderIntersections">orderIntersections</a></li></ul></li><li><a href="module-geometries_voxel.html">geometries/voxel</a></li><li><a href="module-helpers.html">helpers</a></li><li><a href="module-helpers_border.html">helpers/border</a></li><li><a href="module-helpers_boundingbox.html">helpers/boundingbox</a></li><li><a href="module-helpers_dummy.html">helpers/dummy</a></li><li><a href="module-helpers_lut.html">helpers/lut</a></li><li><a href="module-helpers_progressBar.html">helpers/progressBar</a></li><li><a href="module-helpers_slice.html">helpers/slice</a></li><li><a href="module-helpers_stack.html">helpers/stack</a><ul class='methods'><li data-type='method'><a href="module-helpers_stack.html#_create">_create</a></li><li data-type='method'><a href="module-helpers_stack.html#_isIndexOutOfBounds">_isIndexOutOfBounds</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareBBox">_prepareBBox</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareBorder">_prepareBorder</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareDirection">_prepareDirection</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSlice">_prepareSlice</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSliceIndex">_prepareSliceIndex</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareSlicePosition">_prepareSlicePosition</a></li><li data-type='method'><a href="module-helpers_stack.html#_prepareStack">_prepareStack</a></li></ul></li><li><a href="module-helpers_volumerendering.html">helpers/volumerendering</a></li><li><a href="module-helpers_voxel.html">helpers/voxel</a></li><li><a href="module-loaders.html">loaders</a></li><li><a href="module-loaders_base.html">loaders/base</a><ul class='methods'><li data-type='method'><a href="module-loaders_base.html#free">free</a></li></ul></li><li><a href="module-loaders_volumes.html">loaders/volumes</a></li><li><a href="module-models.html">models</a></li><li><a href="module-models_base.html">models/base</a><ul class='methods'><li data-type='method'><a href="module-models_base.html#_validateModelArray">_validateModelArray</a></li><li data-type='method'><a href="module-models_base.html#merge">merge</a></li><li data-type='method'><a href="module-models_base.html#mergeModels">mergeModels</a></li><li data-type='method'><a href="module-models_base.html#validate">validate</a></li></ul></li><li><a href="module-models_frame.html">models/frame</a><ul class='methods'><li data-type='method'><a href="module-models_frame.html#_compareArrays">_compareArrays</a></li><li data-type='method'><a href="module-models_frame.html#cosines">cosines</a></li><li data-type='method'><a href="module-models_frame.html#merge">merge</a></li></ul></li><li><a href="module-models_series.html">models/series</a><ul class='methods'><li data-type='method'><a href="module-models_series.html#merge">merge</a></li><li data-type='method'><a href="module-models_series.html#mergeSeries">mergeSeries</a></li><li data-type='method'><a href="module-models_series.html#validate">validate</a></li></ul></li><li><a href="module-models_stack.html">models/stack</a><ul class='methods'><li data-type='method'><a href="module-models_stack.html#prepare">prepare</a></li></ul></li><li><a href="module-models_voxel.html">models/voxel</a></li><li><a href="module-parsers.html">parsers</a></li><li><a href="module-parsers_dicom.html">parsers/dicom</a><ul class='methods'><li data-type='method'><a href="module-parsers_dicom.html#_swapFrame">_swapFrame</a></li></ul></li><li><a href="module-parsers_nifti.html">parsers/nifti</a></li><li><a href="module-parsers_volume.html">parsers/volume</a></li><li><a href="module-shaders.html">shaders</a></li><li><a href="module-shaders_data.html">shaders/data</a></li><li><a href="module-shaders_layer.html">shaders/layer</a></li><li><a href="module-shaders_raycasting.html">shaders/raycasting</a></li><li><a href="module-widgets.html">widgets</a></li><li><a href="module-widgets_handle.html">widgets/handle</a><ul class='methods'><li data-type='method'><a href="module-widgets_handle.html#onMove">onMove</a></li></ul></li><li><a href="module-widgets_squareProbe.html">widgets/squareProbe</a></li><li><a href="module-widgets_voxelProbe.html">widgets/voxelProbe</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">core/core.intersections.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Utils      from './core.utils';
import Validators from './core.validators';

/** 
 * Compute/test intersection between different objects.
 *
 * @module core/intersections
 */

export default class Intersections {

/**
 * Compute intersection between oriented bounding box and a plane.
 *
 * Returns intersection in plane's space.
 *
 * Should return at least 3 intersections. If not, the plane and the box do not
 * intersect.
 *
 * @param {Object} aabb - Axe Aligned Bounding Box representation.
 * @param {THREE.Vector3} aabb.halfDimensions - Half dimensions of the box.
 * @param {THREE.Vector3} aabb.center - Center of the box.
 * @param {THREE.Matrix4} aabb.toAABB - Transform to go from plane space to box space.
 * @param {Object} plane - Plane representation
 * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
 * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
 *
 * @returns {Array&lt;THREE.Vector3>} List of all intersections in plane's space.
 * @returns {boolean} false is invalid input provided.
 *
 * @example
 * //Returns array with intersection N intersections
 * let aabb = {
 *   center: new THREE.Vector3(150, 150, 150),
 *   halfDimensions: new THREE.Vector3(50, 60, 70),
 *   toAABB: new THREE.Matrix4()
 * }
 * let plane = {
 *   position: new THREE.Vector3(110, 120, 130),
 *   direction: new THREE.Vector3(1, 0, 0)
 * }
 *
 * let intersections = CoreIntersections.aabbPlane(aabb, plane);
 * // intersections ==
 * //[ { x : 110, y : 90,  z : 80 },
 * //  { x : 110, y : 210, z : 220 },
 * //  { x : 110, y : 210, z : 80 },
 * //  { x : 110, y : 90,  z : 220 } ]
 *
 * //Returns empty array with 0 intersections
 * let aabb = {
 * 
 * }
 * let plane = {
 *  
 * }
 *
 * let intersections = VJS.Core.Validators.matrix4(new THREE.Vector3());
 *
 * //Returns false if invalid input?
 *
 */
  static aabbPlane(aabb, plane) {
    //
    // obb = { halfDimensions, orientation, center, toAABB }
    // plane = { position, direction }
    //
    //
    // LOGIC:
    //
    // Test intersection of each edge of the Oriented Bounding Box with the Plane
    // 
    // ALL EDGES 
    //
    //      .+-------+  
    //    .' |     .'|  
    //   +---+---+'  |  
    //   |   |   |   |  
    //   |  ,+---+---+  
    //   |.'     | .'   
    //   +-------+'     
    //
    // SPACE ORIENTATION
    //
    //       +
    //     j |
    //       |
    //       |   i 
    //   k  ,+-------+  
    //    .'
    //   +
    //
    //
    // 1- Move Plane position and orientation in IJK space
    // 2- Test Edges/ IJK Plane intersections
    // 3- Return intersection Edge/ IJK Plane if it touches the Oriented BBox

    let intersections = [];

    if(!(this.validateAabb(aabb) &amp;&amp;
       this.validatePlane(plane))){
      window.console.log('Invalid aabb or plane provided.');
      return false;
    }

    // invert space matrix
    let fromAABB = new THREE.Matrix4();
    fromAABB.getInverse(aabb.toAABB);

    let t1 = plane.direction.clone().applyMatrix4(aabb.toAABB);
    let t0 = new THREE.Vector3(0, 0, 0).applyMatrix4(aabb.toAABB);

    let planeAABB = this.posdir(
      plane.position.clone().applyMatrix4(aabb.toAABB),
      new THREE.Vector3(t1.x - t0.x, t1.y - t0.y, t1.z - t0.z).normalize()
    );

    let bbox = Utils.bbox(aabb.center, aabb.halfDimensions);

    let orientation = new THREE.Vector3(
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, 0, 1));

    // 12 edges (i.e. ray)/plane intersection tests
    // RAYS STARTING FROM THE FIRST CORNER (0, 0, 0)
    //
    //       +
    //       |
    //       |
    //       | 
    //      ,+---+---+
    //    .'   
    //   +   

    let ray = this.posdir(
      new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z),
      orientation.x
    );
    this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

    ray.direction = orientation.y;
    this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

    ray.direction = orientation.z;
    this.rayPlaneInBBox(ray, planeAABB, bbox, intersections);

    // RAYS STARTING FROM THE LAST CORNER
    //
    //               +
    //             .'
    //   +-------+'
    //           |
    //           |
    //           |
    //           +
    //

    let ray2 = this.posdir(
      new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z),
      orientation.x
    );
    this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

    ray2.direction = orientation.y;
    this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

    ray2.direction = orientation.z;
    this.rayPlaneInBBox(ray2, planeAABB, bbox, intersections);

    // RAYS STARTING FROM THE SECOND CORNER
    //
    //               +
    //               |
    //               |
    //               |
    //               +
    //             .'
    //           +'

    let ray3 = this.posdir(
      new THREE.Vector3(aabb.center.x + aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z),
      orientation.y
    );
    this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

    ray3.direction = orientation.z;
    this.rayPlaneInBBox(ray3, planeAABB, bbox, intersections);

    // RAYS STARTING FROM THE THIRD CORNER
    //
    //      .+-------+  
    //    .'
    //   +
    //   
    //   
    //   
    //   

    let ray4 = this.posdir(
      new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y + aabb.halfDimensions.y, aabb.center.z - aabb.halfDimensions.z),
      orientation.x
    );
    this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

    ray4.direction = orientation.z;
    this.rayPlaneInBBox(ray4, planeAABB, bbox, intersections);

    // RAYS STARTING FROM THE FOURTH CORNER
    //
    //   
    //   
    //   +
    //   |
    //   |  
    //   |
    //   +-------+

    let ray5 = this.posdir(
      new THREE.Vector3(aabb.center.x - aabb.halfDimensions.x, aabb.center.y - aabb.halfDimensions.y, aabb.center.z + aabb.halfDimensions.z),
      orientation.x
    );
    this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

    ray5.direction = orientation.y;
    this.rayPlaneInBBox(ray5, planeAABB, bbox, intersections);

    // @todo make sure objects are unique...

    // back to original space
    intersections.map(
      function(element) {
        return element.applyMatrix4(fromAABB);
      }
    );

    return intersections;
  }

/**
 * Compute intersection between a ray and a plane.
 *
 * @memberOf this
 * @public
 *
 * @param {Object} ray - Ray representation.
 * @param {THREE.Vector3} ray.position - position of normal which describes the ray.
 * @param {THREE.Vector3} ray.direction - Direction of normal which describes the ray.
 * @param {Object} plane - Plane representation
 * @param {THREE.Vector3} plane.position - position of normal which describes the plane.
 * @param {THREE.Vector3} plane.direction - Direction of normal which describes the plane.
 *
 * @returns {THREE.Vector3|null} Intersection between ray and plane or null.
 */
  static rayPlane(ray, plane) {
  // ray: {position, direction}
  // plane: {position, direction}

  if (ray.direction.dot(plane.direction) !== 0) {
    //
    // not parallel, move forward
    //
    // LOGIC:
    //
    // Ray equation: P = P0 + tV
    // P = &lt;Px, Py, Pz>
    // P0 = &lt;ray.position.x, ray.position.y, ray.position.z>
    // V = &lt;ray.direction.x, ray.direction.y, ray.direction.z>
    //
    // Therefore:
    // Px = ray.position.x + t*ray.direction.x
    // Py = ray.position.y + t*ray.direction.y
    // Pz = ray.position.z + t*ray.direction.z
    //
    //
    //
    // Plane equation: ax + by + cz + d = 0
    // a = plane.direction.x
    // b = plane.direction.y
    // c = plane.direction.z
    // d = -( plane.direction.x*plane.position.x +
    //        plane.direction.y*plane.position.y +
    //        plane.direction.z*plane.position.z )
    //
    //
    // 1- in the plane equation, we replace x, y and z by Px, Py and Pz
    // 2- find t
    // 3- replace t in Px, Py and Pz to get the coordinate of the intersection
    //
    let t = (plane.direction.x * (plane.position.x - ray.position.x) + plane.direction.y * (plane.position.y - ray.position.y) + plane.direction.z * (plane.position.z - ray.position.z)) /
        (plane.direction.x * ray.direction.x + plane.direction.y * ray.direction.y + plane.direction.z * ray.direction.z);

    let intersection = new THREE.Vector3(
        ray.position.x + t * ray.direction.x,
        ray.position.y + t * ray.direction.y,
        ray.position.z + t * ray.direction.z);

    return intersection;

  }

  return null;

}

  static rayBox(ray, box) {
    // should also do the space transforms here
    // ray: {position, direction}
    // box: {halfDimensions, center}

    let intersections = [];
    
    let bbox = Utils.bbox(box.center, box.halfDimensions);

    // window.console.log(bbox);

    // X min
    let plane = this.posdir(
      new THREE.Vector3(
        bbox.min.x,
        box.center.y,
        box.center.z),
      new THREE.Vector3(-1, 0, 0)
    );
    this.rayPlaneInBBox(ray, plane, bbox, intersections);

    // X max
    plane = this.posdir(
      new THREE.Vector3(
        bbox.max.x,
        box.center.y,
        box.center.z),
      new THREE.Vector3(1, 0, 0)
    );
    this.rayPlaneInBBox(ray, plane, bbox, intersections);

    // Y min
    plane = this.posdir(
      new THREE.Vector3(
        box.center.x,
        bbox.min.y,
        box.center.z),
      new THREE.Vector3(0, -1, 0)
    );
    this.rayPlaneInBBox(ray, plane, bbox, intersections);

    // Y max
    plane = this.posdir(
      new THREE.Vector3(
        box.center.x,
        bbox.max.y,
        box.center.z),
      new THREE.Vector3(0, 1, 0)
    );
    this.rayPlaneInBBox(ray, plane, bbox, intersections);

    // Z min
    plane = this.posdir(
      new THREE.Vector3(
        box.center.x,
        box.center.y,
        bbox.min.z),
      new THREE.Vector3(0, 0, -1)
    );
    this.rayPlaneInBBox(ray, plane, bbox, intersections);

    // Z max
    plane = this.posdir(
      new THREE.Vector3(
        box.center.x,
        box.center.y,
        bbox.max.z),
      new THREE.Vector3(0, 0, 1)
    );
    this.rayPlaneInBBox(ray, plane, bbox, intersections);

    return intersections;
  }


  static rayPlaneInBBox(ray, planeAABB, bbox, intersections) {
    let intersection = this.rayPlane(ray, planeAABB);
    // window.console.log(intersection);
    if (intersection &amp;&amp; this.inBBox(intersection, bbox)){
      if(!intersections.find(this.findIntersection(intersection))){
        intersections.push(intersection);
      }
    }
  }

  static findIntersection(myintersection){
    return function found(element, index, array) {
      if(myintersection.x === element.x &amp;&amp;
        myintersection.y === element.y &amp;&amp;
        myintersection.z === element.z){
        return true;
      }

      return false;
    }
  }

  static inBBox(point, bbox) {
    //
    let epsilon = 0.0001;
    if (point &amp;&amp;
        point.x >= bbox.min.x - epsilon &amp;&amp; point.y >= bbox.min.y - epsilon &amp;&amp; point.z >= bbox.min.z - epsilon &amp;&amp;
        point.x &lt;= bbox.max.x + epsilon &amp;&amp; point.y &lt;= bbox.max.y + epsilon &amp;&amp; point.z &lt;= bbox.max.z + epsilon) {
      return true;
    }
    return false;
  }

  static posdir(position, direction){
    return {position, direction};
  }

  static validatePlane(plane){
    //
    if(plane === null){

      window.console.log('Invalid plane.');
      window.console.log(plane);

      return false;
    }

    if(!Validators.vector3(plane.position)){

      window.console.log('Invalid plane.position.');
      window.console.log(plane.position);

      return false;
    }

    if(!Validators.vector3(plane.direction)){

      window.console.log('Invalid plane.direction.');
      window.console.log(plane.direction);

      return false;
    }

    return true;
  }

  static validateAabb(aabb){
    //
    if(aabb === null){
      window.console.log('Invalid aabb.');
      window.console.log(aabb);
      return false;
    }

    if(!Validators.matrix4(aabb.toAABB)){

      window.console.log('Invalid aabb.toAABB: ');
      window.console.log(aabb.toAABB);

      return false;
    }

    if(!Validators.vector3(aabb.center)){

      window.console.log('Invalid aabb.center.');
      window.console.log(aabb.center);

      return false;
    }

    if(!(Validators.vector3(aabb.halfDimensions) &amp;&amp;
       aabb.halfDimensions.x >= 0 &amp;&amp;
       aabb.halfDimensions.y >= 0 &amp;&amp;
       aabb.halfDimensions.z >= 0)){

      window.console.log('Invalid aabb.halfDimensions.');
      window.console.log(aabb.halfDimensions);

      return false;
    }

    return true;
  }

}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.0-dev</a> on Thu Sep 29 2016 15:06:14 GMT+0200 (CEST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
